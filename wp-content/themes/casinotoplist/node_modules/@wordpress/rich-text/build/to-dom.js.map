{"version":3,"sources":["@wordpress/rich-text/src/to-dom.js"],"names":["TEXT_NODE","window","Node","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","toDom","value","multilineTag","prepareEditableTree","isEditableTree","placeholder","startPath","endPath","formats","tree","onStartIndex","body","pointer","onEndIndex","selection","apply","current","__unstableDomOnly","applyValue","start","undefined","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","nodeName","data","replaceChild","currentAttributes","futureAttributes","ii","name","getAttribute","removeAttribute","isRangeEqual","a","b","startContainer","startOffset","endContainer","endOffset","getSelection","range","createRange","setStart","setEnd","activeElement","rangeCount","getRangeAt","removeAllRanges","addRange","HTMLElement","focus","blur"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\n/**\n * Returns a new instance of a DOM tree upon which RichText operations can be\n * applied.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createEmpty`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @return {Object} RichText tree.\n */\nconst createEmpty = () => createElement( document, '' );\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      $1                        Named arguments.\n * @param {Object}      $1.value                  Value to apply.\n * @param {HTMLElement} $1.current                The live root node to apply the element tree to.\n * @param {string}      [$1.multilineTag]         Multiline tag.\n * @param {Array}       [$1.multilineWrapperTags] Tags where lines can be found if nesting is possible.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst selection = window.getSelection();\n\tconst { ownerDocument } = current;\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state. `activeElement` can be `null` or the body element if\n\t// there is no focus, which is accounted for here in the explicit `blur` to\n\t// restore to a state of non-focus.\n\tif ( activeElement !== document.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement ) {\n\t\t\tif ( activeElement instanceof window.HTMLElement ) {\n\t\t\t\tactiveElement.focus();\n\t\t\t}\n\t\t} else if ( document.activeElement instanceof window.HTMLElement ) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\t}\n}\n"]}