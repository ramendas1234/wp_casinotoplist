'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('reakit-utils/warning');
var React = require('react');
require('../Id/IdProvider.js');
var createComponent = require('reakit-system/createComponent');
var createHook = require('reakit-system/createHook');
require('../Box/Box.js');
var _rollupPluginBabelHelpers = require('../_rollupPluginBabelHelpers-baac11a7.js');
var useForkRef = require('reakit-utils/useForkRef');
require('reakit-utils/isButton');
require('reakit-utils/tabbable');
require('reakit-utils/hasFocusWithin');
require('../Tabbable/Tabbable.js');
require('../Button/Button.js');
var useAllCallbacks = require('reakit-utils/useAllCallbacks');
require('reakit-utils/useSealedState');
require('../Id/IdState.js');
require('reakit-utils/useIsomorphicEffect');
require('../Disclosure/DisclosureState.js');
require('reakit-utils/removeItemFromArray');
require('../Dialog/DialogState.js');
require('../Disclosure/Disclosure.js');
require('../Dialog/DialogDisclosure.js');
var createOnKeyDown = require('reakit-utils/createOnKeyDown');
require('../Id/Id.js');
require('../Rover/RoverState.js');
require('../Rover/Rover.js');
require('@popperjs/core');
require('../Popover/PopoverState.js');
var MenuState = require('../MenuState-4d4edfa6.js');
require('./MenuBarState.js');
var PopoverDisclosure = require('../Popover/PopoverDisclosure.js');

var noop = function noop() {};

var useMenuButton = createHook.createHook({
  name: "MenuButton",
  compose: PopoverDisclosure.usePopoverDisclosure,
  useState: MenuState.useMenuState,
  useProps: function useProps(options, _ref) {
    var htmlRef = _ref.ref,
        htmlOnClick = _ref.onClick,
        htmlOnKeyDown = _ref.onKeyDown,
        htmlOnFocus = _ref.onFocus,
        htmlOnMouseOver = _ref.onMouseOver,
        htmlProps = _rollupPluginBabelHelpers._objectWithoutPropertiesLoose(_ref, ["ref", "onClick", "onKeyDown", "onFocus", "onMouseOver"]);

    var parent = React.useContext(MenuState.MenuContext);
    var ref = React.useRef(null); // This avoids race condition between focus and click.
    // On some browsers, focus is triggered right before click.
    // So we use it to disable toggling.

    var _React$useState = React.useState(false),
        hasShownOnFocus = _React$useState[0],
        setHasShownOnFocus = _React$useState[1];

    var _options$placement$sp = options.placement.split("-"),
        dir = _options$placement$sp[0];

    var hasParent = Boolean(parent);
    var parentIsMenuBar = parent && parent.role === "menubar";
    var onKeyDown = React.useMemo(function () {
      return createOnKeyDown.createOnKeyDown({
        stopPropagation: function stopPropagation(event) {
          return event.key !== "Escape";
        },
        onKey: options.show,
        keyMap: function keyMap() {
          // prevents scroll jump
          var first = function first() {
            return setTimeout(options.first);
          };

          return {
            Escape: options.hide,
            Enter: hasParent && first,
            " ": hasParent && first,
            ArrowUp: dir === "top" || dir === "bottom" ? options.last : false,
            ArrowRight: dir === "right" && first,
            ArrowDown: dir === "bottom" || dir === "top" ? first : false,
            ArrowLeft: dir === "left" && first
          };
        }
      });
    }, [dir, hasParent, options.show, options.hide, options.first, options.last]);
    var onFocus = React.useCallback(function () {
      if (parentIsMenuBar) {
        setHasShownOnFocus(true);
        options.show();
      }
    }, [parentIsMenuBar, options.show]); // Restores hasShownOnFocus

    React.useEffect(function () {
      if (!hasShownOnFocus) return undefined;
      var id = setTimeout(function () {
        return setHasShownOnFocus(false);
      }, 200);
      return function () {
        return clearTimeout(id);
      };
    }, [hasShownOnFocus]);
    var onMouseOver = React.useCallback(function (event) {
      // MenuButton's don't do anything on mouse over when they aren't
      // cointained within a Menu/MenuBar
      if (!parent) return;
      var self = event.currentTarget;

      if (parentIsMenuBar) {
        // if MenuButton is an item inside a MenuBar, it'll only open
        // if there's already another sibling expanded MenuButton
        var subjacentOpenMenu = parent.ref.current && parent.ref.current.querySelector("[aria-expanded='true']");

        if (subjacentOpenMenu) {
          self.focus();
        }
      } else {
        // If it's in a Menu, open after a short delay
        // TODO: Make the delay a prop?
        setTimeout(function () {
          if (self.contains(document.activeElement)) {
            options.show();

            if (document.activeElement !== self) {
              self.focus();
            }
          }
        }, 200);
      }
    }, [parent, parentIsMenuBar, options.show]); // If disclosure is rendered as a menu bar item, it's toggable
    // That is, you can click on the expanded disclosure to close its menu
    // But, if disclosure has been focused, it may be result of a mouse down
    // In this case, toggling it would make it close right away on click
    // Then we check if it has been shown on focus. If so, we don't toggle

    var onClick = React.useCallback(function () {
      if (hasParent && (!parentIsMenuBar || hasShownOnFocus)) {
        options.show();
      } else {
        options.toggle();
      }
    }, [hasParent, parentIsMenuBar, hasShownOnFocus, options.show, options.toggle]);
    return _rollupPluginBabelHelpers._objectSpread2({
      ref: useForkRef.useForkRef(ref, htmlRef),
      "aria-haspopup": "menu",
      onClick: useAllCallbacks.useAllCallbacks(onClick, htmlOnClick),
      onKeyDown: useAllCallbacks.useAllCallbacks(onKeyDown, htmlOnKeyDown),
      onFocus: useAllCallbacks.useAllCallbacks(onFocus, htmlOnFocus),
      onMouseOver: useAllCallbacks.useAllCallbacks(onMouseOver, htmlOnMouseOver)
    }, htmlProps);
  },
  useComposeOptions: function useComposeOptions(options) {
    return _rollupPluginBabelHelpers._objectSpread2({}, options, {
      // Toggling is handled by MenuButton
      toggle: noop
    });
  }
});
var MenuButton = createComponent.createComponent({
  as: "button",
  useHook: useMenuButton
});

exports.MenuButton = MenuButton;
exports.useMenuButton = useMenuButton;
